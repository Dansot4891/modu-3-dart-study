## 응집도 (Cohesion)
- 모듈이 하나의 목적을 수행하는 요소들간의 연관성 척도
- 모듈 내부의 기능적인 응집 정도를 나타냄
    **높은 응집도 : 모듈이 하나의 특정 작업이나 기능에 집중** 
        => UserAuthentication 클래스 : 로그인, 로그아웃, 비밀번호 변경 기능
    **낮은 응집도 : 모듈이 여러 가지 서로 관련 없는 작업을 수행**
        => Util 클래스 : 문자열 처리, 파일 읽기, 날짜 계산 기능
        
## 결합도 (Coupling)
- 모듈이 다른 모듈에 의존하는 정도의 척도
- 모듈과 모듈간의 상호 결합 정도를 나타냄
    **낮은 결합도 : 모듈이 서로 독립적으로 작동할 수 있을 때**
        => UserAuthentication 클래스가 특정 클래스가 아니라 인터페이스를 통해 사용자 정보를 가져오는 경우
    **높은 결합도 : 모듈이 서로 강하게 연결되어 있을 때**
        => UserAuthentication 클래스가 특정 클래스의 내부 구현에 직접 의존하는 경우

## 좋은 코드를 위해 의식해야 하는 6가지 코드 작성의 원칙
1. DRY : 같은 것을 몇번씩 반복하지 말라
    - 중복 코드가 있다면 메소드로 분리한다
2. PIE : 명확하고 표현력 있게 기술하자
    - 애매한 이름은 쓰지 말자
    - 누가 봐도 알기 쉬운 이름을 쓰자
    - 컨벤션을 따르자
    - 매직 넘버에 이름을 붙이자
3. SRP : 클래스에 주어진 책임은 1개뿐
    - 단일 책임 원칙
    - 1개의 클래스는 1개의 일만한다. (한 클래스는 하나의 책임만 가진다)
    - 한 부분의 에러를 수정하기 위해서는 그 클래스만 수정하면 된다.
    - 하지만 클래스 분리가 심해지면 오히려 관리가 어렵기도 하다.
4. OCP : 개방 폐쇄 원칙
- 확장에 대해서는 열려있고 (확장은 자유롭고), 변경에 대해서는 닫혀있다 (의존 부분의 변경은 불필요)
- 즉, 수정 없이 확장 가능하도록 하자.
- Iterable, Comparator 등이 좋은 예
- String 의 경우는 상속 금지이므로 OCP에 반하는 클래스의 대표적인 예.
- 인터페이스를 적극 활용하여 확장 가능하게 하자.
5. SDP : 안전한 것에 의존하라
- ATM 시스템을 예를 들면 암호 처리 같이 한번 완성되면 수정될 가능성이 없는 클래스에 의존할 만 하다
- 하지만 가장 좋은 것은 특정 클래스가 아니라 인터페이스에 의존하는 것이다
- 클래스는 생성자가 변하거나 할 수 있으나 인터페이스는 거의 그대로이니까.
    **Ex 변경 가능성 : Random 을 직접 사용하는 대신, Random을 감싸는 인터페이스를 사용하라**
6. ADP - 의존성 비순환 원칙
- 의존 관계에 사이클이 발생되지 않게 한다

## SOLID 원칙
1. SRP : 클래스에 주어진 책임은 1개뿐
    - 단일 책임 원칙
    - 1개의 클래스는 1개의 일만한다. (한 클래스는 하나의 책임만 가진다)
2. OCP : 개방 폐쇄 원칙
    - 확장에 대해서는 열려있고 (확장은 자유롭고), 변경에 대해서는 닫혀있다 (의존 부분의 변경은 불필요)
    - 즉, 수정 없이 확장 가능하도록 하자.
3. LST : 리스코프 치환 원칙
    - is a 원칙을 지켜라 => 상속을 잘 사용해라
4. ISP : 인터페이스 분리 원칙
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
5. DIP : 의존관계 역전 법칙
    - 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.

## 디자인 패턴
- 디자인 패턴은 프로그래머가 어플리케이션이나 시스템을 디자인할 때 공통된 문제들을 해결하는데에 쓰이는 형식화 된 가장 좋은 관행
    1. 빌더(Builder)
        => 빌더 패턴은 복잡한 객체를 단계적으로 생성하는 데 유용 (StringBuffer)
    2. 팩토리(Factory)
        => 인스턴스를 만드는 패턴
    3. 싱글톤(Singleton)
        => 1개의 인스턴스만 생성되는 것을 보증하기 위한 패턴
        => 인스턴스 생성을 여러번 시도해도 1개의 인스턴스가 공유됨
        => 캐시나 공유 데이터, 처리의 효율화 등에 사용되는 테크닉
    4. Decorator 패턴 (Flutter)
        => 감싸고 감싸며 결국 하나의 인스턴스로 동작하게 만드는 패턴
    5. Iterator 패턴
        => 반복 구조 (Iterable)
    6. Facade - 내부를 감추고 심플하게 (http 패키지)
        => 복잡한 하위 시스템을 단순화 하기 위한 패턴
        => 이사를 가면 주소를 변경할 때, 주민센터, 카드회사, 학교 등에 알려야 한다.
        => 이를 하나하나 일일이 하는 것은 매우 귀찮기 때문에 한번에 해 주는 서비스가 있다면 그것을 이용하면 된다는 이론
    7. 전략(Strategy) 패턴 - 갈아 끼우기
        => 런타임에 알고리즘을 동적으로 교체할 수 있도록
    8. 옵저버(Observer) 패턴
        => 옵저버 패턴(observer pattern)은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 
        => 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. 발행/구독 모델로 알려져 있기도 하다.

## 아키텍처 디자인 패턴
1. MVC
2. MVC2
3. MVP
4. MVVM
5. MVI
